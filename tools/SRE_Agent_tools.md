This document contains all the tools available for the Azure SRE Agent. This document is organized by Sections, Tool name and Description.
For example first section is: Azure Operation, the first tool in this section is CheckIfResourceExists followed by its description. Second tool name is CheckTcpConnectivity and go on

# Azure Operation

## CheckIfResourceExists
Checks if a resource exists in Azure by validating the provided resource ID against Azure Resource Manager. This tool is essential for confirming resource availability before performing operations, troubleshooting scenarios where resources appear to be missing, and validating that deployments have completed successfully. It takes an app resource ID as input and returns whether the resource exists in your subscription. Use this to quickly rule out missing resources as a potential cause of issues, verify resource IDs before using them in other operations, or confirm that recently deployed resources are available.

## CheckTcpConnectivity
Checks if a TCP connection from a given Azure resource to a target host can be established on a specified port. This diagnostic tool tests network connectivity from the perspective of your Azure resource, helping identify firewall rule problems, Network Security Group (NSG) misconfigurations, DNS resolution failures, and network path issues. You provide the full resource ID of an Azure resource, the target host to test connectivity to, and the port number. The tool simulates a real connection attempt and reports whether the endpoint is reachable. Use this when applications report connection timeouts, when validating network security configurations, or when verifying that backend services are accessible from your application tier.

## DisableAzureFrontDoorEndpointOrigin
Disables an origin server in Azure Front Door, immediately stopping traffic from being routed to that backend. This is a critical incident response action that removes unhealthy, overloaded, or problematic backends from traffic rotation without deleting the configuration. When disabled, Front Door's load balancer will route traffic to remaining enabled origins. Use this for emergency response when a backend is failing, for planned maintenance requiring traffic diversion, for gradual rollouts and rollbacks, or when investigating issues that require isolating specific backends. The origin configuration is preserved and can be re-enabled. This operation takes effect within seconds globally.

## DisableTrafficManagerEndpoint
Disables (takes offline) an Azure Traffic Manager endpoint, immediately stopping traffic from being routed to that backend. You specify the subscription ID, resource group name, Traffic Manager profile name, endpoint name, and endpoint type (azureEndpoints, externalEndpoints, or nestedEndpoints). This is a critical incident response tool for quickly removing unhealthy or problematic endpoints from traffic rotation without deleting them. Common use cases include: emergency maintenance, isolating misbehaving regions during incidents, blue-green deployments, and removing endpoints returning errors. The endpoint remains configured but receives no traffic until re-enabled. Traffic Manager automatically routes to remaining healthy endpoints based on your routing method.

## EnableAzureFrontDoorEndpointOrigin
Enables an origin server within an Azure Front Door endpoint, allowing it to receive traffic. Origins are backend servers (web apps, storage, custom hosts, etc.) that serve content through Front Door's global edge network. When enabled, Front Door's load balancer will include it in traffic distribution according to configured routing rules, health probes, and load balancing settings. Use this to bring backend servers back into rotation after maintenance, after recovering from failures, or after scaling up capacity. Before enabling, consider verifying the origin's health to ensure it's ready for production traffic.

## EnableTrafficManagerEndpoint
Enables (brings online) an Azure Traffic Manager endpoint, allowing it to resume receiving traffic according to your routing configuration. You specify the subscription ID, resource group name, Traffic Manager profile name, endpoint name, and endpoint type (azureEndpoints, externalEndpoints, or nestedEndpoints). Use this to bring endpoints back into traffic rotation after maintenance, incident resolution, or when an endpoint is healthy again. Before enabling, verify the endpoint's health to ensure it's ready for production traffic. Traffic will gradually shift to the newly enabled endpoint based on your Traffic Manager routing method (Priority, Weighted, Performance, Geographic, or MultiValue).

## GetAllAzureDataFactoryPipelinesStatus
Retrieves the status of all pipelines in an Azure Data Factory, providing a comprehensive overview of data workflow health including running, succeeded, failed, and queued executions. This holistic view helps understand the current state of data operations, identify failures requiring attention, monitor ongoing executions, and assess overall Data Factory health. The status information includes pipeline names, run states, start and end times, error messages for failures, and trigger information. Use this for operational dashboards, morning health checks, investigating whether data processing issues might be affecting dependent systems, and identifying patterns of failures across multiple pipelines.

## GetAllAzureFrontDoorEndpointOriginsStatus
Retrieves health and configuration status for all origin servers in an Azure Front Door endpoint, providing complete visibility into backend availability and routing state. The status information includes each origin's enabled/disabled state, health probe results, HTTP health status, latency measurements, and configuration details like weight and priority. This holistic view is essential for understanding traffic distribution, identifying unhealthy backends, diagnosing routing issues, and monitoring Front Door deployment health. Use this for health monitoring dashboards, troubleshooting routing anomalies, verifying configuration after changes, and incident investigation involving Front Door-served applications.

## GetAppSetting
Retrieves the key-value pair for a specific App Setting key from an Azure resource. You provide the full resource ID and the App Setting key name to look up. Application settings are key-value pairs that configure your application's runtime behavior, including connection strings, feature flags, API keys, and environment-specific configurations. This tool is essential for troubleshooting configuration-related issues, verifying that deployments have applied the correct settings, and auditing configuration values during incident investigation. Use this when you need to check the current value of a specific configuration setting.

## GetArmResourceAsJson
Gets the ARM (Azure Resource Manager) properties of a resource as JSON. You provide the full resource ID and receive the complete resource definition including all properties, tags, SKU information, identity configuration, network settings, and metadata. The ARM representation is the authoritative source of truth for how a resource is configured in Azure. Use this for deep inspection during troubleshooting, comparing actual configuration against expected state, exporting resource definitions for documentation, and understanding the complete state of a resource. The JSON output can be compared against ARM templates or previous snapshots to identify configuration drift.

## GetAzCliHelp
Retrieves comprehensive help documentation for Azure CLI commands, including syntax, required and optional parameters, examples, and usage notes. This tool is your guide to understanding how to use the Azure CLI effectively when executing read or write commands against Azure resources. It provides contextual help for any az command, showing parameter descriptions, accepted values, default behaviors, and real-world examples. Use this before running complex Azure CLI operations to ensure you're using the correct parameters and understand the expected outcomes. The help documentation is sourced directly from the Azure CLI, ensuring accuracy and completeness.

## GetTlsSettings
Gets the TLS settings for a list of Azure resources, checking the minimum TLS version configured for each. You provide a list of resource IDs and receive the TLS configuration including minimum TLS version enforced. TLS settings are critical for security compliance and ensuring secure communications between clients and your Azure services. Use this to verify that resources meet security requirements (such as enforcing TLS 1.2 or higher), audit multiple resources at once, diagnose TLS handshake failures, and ensure compliance with organizational security policies. Particularly useful when preparing for security audits or troubleshooting HTTPS connection issues.

## PowerOnVirtualMachine
Powers ON an Azure virtual machine, starting a stopped or deallocated VM and bringing it back online. You provide the full resource ID of the Azure virtual machine resource. Use this for incident response scenarios where VMs need to be brought online urgently, recovering from unexpected shutdowns, scheduled maintenance recovery, or scaling up capacity during high-demand periods. The tool handles both stopped VMs (still incurring compute charges) and deallocated VMs (not incurring compute charges). Note that starting a deallocated VM may result in a different underlying host assignment and potentially a new public IP address if not using a static IP.

## RestartAzureDataFactoryPipeline
Restarts an Azure Data Factory pipeline, allowing re-execution from the beginning or from a specific point depending on the failure scenario. This tool is essential for recovery after pipeline failures, reprocessing data after corrections, and resuming interrupted workflows. The restart behavior can be configured to rerun all activities or only failed activities. For pipelines with checkpointing enabled, restart may resume from the last checkpoint. Use this for recovering from transient failures (network issues, temporary resource unavailability), reprocessing after data corrections, completing interrupted runs, and implementing retry logic for robust data workflows.

## RestartWebApp
Restarts an Azure App Service app by providing its resource ID. This is one of the most common and effective troubleshooting actions for web applications, capable of resolving transient issues including memory leaks, stuck threads, cached state corruption, connection pool exhaustion, and configuration refresh requirements. The restart operation gracefully stops the application, clears in-memory state, and starts fresh instances. During restart, the app will be temporarily unavailable (typically 10-60 seconds depending on cold start time). Use this after configuration changes that require a restart, after deploying updates that need a clean start, or when the application is exhibiting unexpected behavior.

## RunAzCliReadCommands
Executes read-only Azure CLI commands to safely query and inspect Azure resources without making any modifications to your infrastructure. This is your primary tool for gathering information about Azure resources using the full power of the Azure CLI. You can run any 'az' command that retrieves information, lists resources, shows configurations, or queries status. Examples include: 'az vm show', 'az webapp log', 'az network nsg rule list', 'az monitor metrics list', and many more. The tool enforces read-only operations, preventing accidental modifications during investigation. Output is returned in JSON format for easy parsing and analysis. Use this tool when you need detailed resource information that isn't available through other specialized tools.

## RunAzCliWriteCommands
Executes Azure CLI commands that modify Azure resources, enabling you to make configuration changes, update settings, create resources, or perform management operations. This powerful tool requires careful consideration before use, as it can make permanent changes to your Azure infrastructure. Examples include: 'az vm restart', 'az webapp config set', 'az network nsg rule create', 'az storage account update', and other modification commands. The tool requires appropriate Azure RBAC permissions for the operations being performed. Use this tool when you need to implement fixes, apply configuration changes during incident response, or perform remediation actions. Always verify the command and its parameters before execution, especially in production environments.

## RunAzureDataFactoryPipeline
Triggers execution of an Azure Data Factory pipeline on demand. Data Factory pipelines automate data workflows including ETL (Extract, Transform, Load), data migration, data preparation, and complex data processing tasks. This tool initiates a pipeline run with optional parameter values and returns a run identifier for tracking. Use this for manual pipeline triggering during incidents (when scheduled runs may have failed), testing pipeline behavior, triggering dependent workflows, recovering from failed runs, or executing ad-hoc data operations. The pipeline execution runs asynchronously—use the run ID to monitor progress.

## SetMinimumTlsVersion
Sets the minimum TLS version on a site resource. You provide the app resource ID and the minimum TLS version to set (valid values: 1.2, 1.3). This security configuration enforces that all client connections must use the specified TLS version or higher. Commonly used to enforce TLS 1.2 or TLS 1.3 for stronger security. Changing the minimum TLS version immediately affects incoming connections—clients using older TLS versions will be unable to connect. Before making this change, ensure all legitimate clients support the target TLS version to avoid service disruption. Essential for meeting compliance requirements like PCI-DSS, HIPAA, and organizational security standards.

## StopAzureDataFactoryPipeline
Stops a currently running Azure Data Factory pipeline execution, cancelling in-progress activities and preventing further processing. This is an important incident response tool when pipelines are consuming excessive resources, processing incorrect data, or need to be halted for investigation. The stop operation terminates the pipeline run and any currently executing activities. Activities already completed will retain their results. Use this for emergency stops when pipelines are causing problems, for resource conservation, when investigation requires freezing the current state, or when pipeline logic errors are detected during execution.

## UpdateAppSettings
Updates specific configuration values in the App Settings for a given Azure resource. You provide the full resource ID and key-value pairs of App Settings to update (only include settings that need to be changed). If the first attempt fails, the tool automatically retries once without notifying the user. Application settings control your application's runtime behavior through key-value configuration pairs. Common use cases include: updating connection strings during incident response, toggling feature flags, adjusting timeout values, changing API endpoints, and applying emergency configuration fixes. Changes take effect immediately for most settings, though some may require an application restart.

# Code Analysis

## WaitInMilliSeconds
Pauses execution for a specified number of milliseconds before proceeding with subsequent operations. This utility tool is essential for workflow orchestration scenarios where timing matters, including: waiting for asynchronous operations to complete, adding delays between API calls to avoid rate limiting, allowing time for eventual consistency in distributed systems, spacing out operations that shouldn't execute simultaneously, and implementing polling patterns with appropriate intervals. The wait is precise to millisecond granularity.

# DevOps

## ConnectRepositoryToResourceForAzureDevOps
Connects or links an Azure Resource to an Azure DevOps (AzDo) repository. This creates an integration link that enables features like deployment status updates, issue linking, and commit tracking. Use this when setting up CI/CD integrations, when linking newly deployed Azure resources to their source code repositories, or when establishing traceability between infrastructure and code. Provide the Azure resource ID and the Azure DevOps repository URL to create the connection.

## CreateAzureDevOpsWorkItem
Creates a work item in Azure DevOps (AzDo/TFS). Creates any work item type: tasks, user stories, bugs, features, epics, test cases, issues, tickets, cards. Works with linked repositories. Use for any request to add, create, make, generate, file, track, or manage work items regardless of phrasing ('add task', 'create bug', 'make story', 'file ticket', 'track work', 'add to backlog', 'create issue', 'new item', etc.). Handles all work tracking scenarios in Azure DevOps. Requires an Azure resource ID to link the work item to a connected repository. You provide the resource ID, title, work item type (Task, Bug, Epic, Feature), description in well-formatted markdown, tags, and optionally an assignee.

## CreateAzureDevOpsWorkItemWithoutResourceLinkage
Creates a work item directly in an Azure DevOps (AzDo/TFS) repository without needing a linked Azure resource. Creates any work item type: tasks, user stories, bugs, features, epics, test cases, issues, tickets, cards. Works directly with repository URLs. Use when you have a specific Azure DevOps repository URL and want to create work items without resource linkage. Handles requests like 'create a task in this specific Azure DevOps repo', 'add a bug to this AzDo repository', 'file an issue in this project', etc. Supports additional options including area path, iteration path, priority, severity, and state.

## CreateGithubIssue
Creates an issue on GitHub to track a problem with a web app which you have diagnosed, especially if you have a solution to fix it. Unless this is a sample issue, make the publisher details comprehensive. Assignees are validated to ensure they are real GitHub users before assignment. If there are credential-related issues, the tool provides a login link to authenticate. You can use Markdown formatting in the description for rich content including code blocks, links, checklists, and images. The tool returns the created issue's URL and number for reference. Use this when you discover problems during investigation that need to be tracked, when creating action items from incident retrospectives, or when documenting bugs found during troubleshooting.

## CreateGithubIssueComment
Creates a comment on a GitHub issue or links a PR to an issue. To link a PR to an issue, comment on the pull request (you can comment on a PR the same way as a regular issue, just fetch them differently). The following keywords auto-close the issue when a linked PR is completed: close, closes, closed, fix, fixes, fixed, resolve, resolves, resolved. Comments support full Markdown including formatted code, links, mentions (@username), and embedded images. Use this during investigations to document progress, share updates with team members, post error logs or diagnostic output, or provide status updates on issue resolution.

## DeleteGithubIssueComment
Removes a comment from a GitHub issue thread, cleaning up outdated, incorrect, or redundant information. While issue history is generally valuable, there are legitimate cases for removing comments: correcting mistakenly posted sensitive information, removing duplicate comments, cleaning up automated comments that are no longer relevant, or removing incorrect analysis that might confuse future readers. This tool deletes the specified comment permanently—it cannot be recovered after deletion. The deletion is logged in GitHub's audit trail. Use this judiciously to maintain clean and accurate issue threads, but prefer adding corrective comments over deletion when the original comment provides useful context about the investigation process.

## DisconnectRepositoryFromResourceForAzureDevOps
Disconnects or unlinks an Azure Resource from an Azure DevOps (AzDo) repository. Removes the connection between a repository and an Azure resource, severing the integration link. Use this when reorganizing projects, migrating between repositories, cleaning up stale integrations after resource moves, or troubleshooting deployment issues. The disconnection removes the link without affecting either the repository or the Azure resource themselves.

## DisconnectRepositoryFromResourceForGitHub
Removes the connection between a GitHub repository and an Azure resource, severing the integration link that enables features like deployment status updates, issue linking, and commit tracking. Repository connections are typically set up during CI/CD configuration to link Azure resources with their source code. Disconnecting is useful when reorganizing projects, migrating between repositories, cleaning up stale integrations after resource moves, or troubleshooting deployment issues that might be caused by misconfigured connections. The disconnection removes the link without affecting either the repository or the Azure resource themselves—they continue to exist independently. Use this when you need to reconfigure deployment integrations, when cleaning up after infrastructure changes, or when troubleshooting GitHub-Azure integration issues.

## FetchGithubIssue
Fetches a specific GitHub issue. If the returned object is empty and is not an exception, there were none found. Retrieves comprehensive information including title, description (body), current state (open/closed), labels, assignees, milestone, creation date, last update, author, and associated metadata. This tool provides the full context of an issue in a single request, essential for reviewing issue details during incident investigation, understanding reported problems, and getting current status. Use this when you need full issue context, when pulling details into analysis, or when gathering information for incident reports.

## FetchGithubIssueComments
Fetches comments for a specific GitHub issue, providing the complete discussion history and context. Comments are returned in chronological order with author information, timestamps, and full Markdown content. This comprehensive view is invaluable for onboarding to ongoing issues, understanding investigation history, finding diagnostic information shared in comments, and reviewing decisions documented during issue resolution. Use this when reviewing issue history, catching up on ongoing investigations, or auditing issue resolution progression.

## FetchGithubIssues
Fetches GitHub issues from a repository. If the returned object is empty and is not an exception, there were none found. If there are more than 3 issues matching, the user should be prompted to be more specific. Supports filtering by state (open/closed/all), labels, assignees, milestone, creator, mentioned users, sort order, and date ranges. Results include issue summaries with titles, states, labels, and key metadata. Use this for discovering related issues during investigation, reviewing open bugs connected to current incidents, finding historical issues with similar symptoms, or generating filtered reports.

## FetchGithubSecurityDependabotAlerts
Fetches all Dependabot issues for a GitHub repository. If the returned object is empty and is not an exception, there were none found. Dependabot continuously monitors dependencies against security vulnerability databases and creates alerts when vulnerable packages are detected. This tool fetches alerts with full details including vulnerable dependency, severity level (Critical, High, Medium, Low), CVE identifiers, affected versions, fixed versions, and remediation guidance. Use this for security audits, assessing exposure to known vulnerabilities, prioritizing dependency updates, and investigating whether security incidents relate to known dependency vulnerabilities.

## FindConnectedGitHubRepo
Finds the GitHub repository URL where source code for an Azure resource like webapp, container app, AKS pod etc. is hosted. This helps identify the correct repository for creating GitHub issues related to code problems such as memory leaks, deadlocks, performance issues, or bugs discovered in Azure resources. The function uses a graph database to trace the relationship between deployed resources and their source code repositories. Returns repository information including owner, name, URL, branch configurations, and deployment settings. Use this as a starting point for source code investigation when you know the Azure resource but need to find its codebase.

## FindConnectedRepositoryForAzureDevOps
Finds the connected or linked Azure DevOps (AzDo/TFS) repository for a given Azure Resource ID. Locates associated repos, git repositories, source code repositories, or code bases linked to Azure resources. Works with any Azure resource type (App Service, Function App, Container Instance, AKS, etc.). Use for requests to find, locate, discover, identify, or get the repository, repo, source code, git repo, or code base connected to Azure resources. Handles variations like 'what repo is linked to this resource', 'find the source code', 'get the repository', 'where is the code', etc.

## GetIaCForAzureDevOps
Retrieves Infrastructure as Code (IaC) files and identifies the IaC type used in the connected Azure DevOps (AzDo) repository for a given Azure Resource. Analyzes and returns IaC templates, configuration files, and deployment scripts from the linked repository. Supports Bicep, ARM templates, Terraform, YAML, and JSON configurations. Use for requests to find, get, analyze, identify, or discover infrastructure code, deployment templates, IaC files, configuration files, or infrastructure definitions associated with Azure resources. Helps understand how resources should be configured and comparing deployed vs. intended configurations.

## GetIaCForGitHub
Gets the type of Infrastructure as Code (IaC) used in a GitHub repository. This tool identifies the most likely IaC type (ARM templates, Bicep, Terraform, Pulumi, etc.) that defines how Azure resources are managed through code. Examining IaC files is crucial for understanding resource configurations, comparing deployed state against intended state, and identifying configuration drift. The tool locates and retrieves IaC files from the repository, making it easy to review infrastructure definitions. Use this for comparing deployed vs. intended configurations, reviewing infrastructure definitions, and understanding how resources should be configured.

## GetUserOrganizations
Gets the names of all organizations a GitHub user is part of. Many enterprises organize repositories across multiple GitHub organizations for different teams, products, or purposes. This tool provides visibility into which organizations you can access, including organization names, avatars, descriptions, and your role in each. The information helps you locate repositories, understand access boundaries, and navigate to the correct organization. Use this when you need to find repositories across organizations, when verifying access permissions, or when orienting yourself within a complex GitHub organization structure.

## UpdateGithubIssue
Updates a GitHub issue. If the user requests to update something that isn't supported, let them know. This tool can modify an issue's title, description (body), state (open/closed), labels, assignees, and milestone. You can update any combination of fields in a single operation. Common use cases include: closing resolved issues, adding labels for categorization, assigning issues to team members, updating descriptions with findings, changing titles to better reflect the actual problem, and moving issues to appropriate milestones. All changes are tracked in GitHub's audit history.

## UpdateGithubIssueComment
Updates a GitHub issue comment. Editing is preferred over deleting and recreating comments because it preserves the comment's position in the thread and shows an 'edited' indicator. This tool replaces the comment's body content while maintaining its original timestamp, author, and position. Use this for correcting errors in posted information, updating status updates as situations change, improving clarity of previous comments, and adding additional information discovered later. The edit history is visible to users who click on the 'edited' indicator.

# Diagnostics

## GetAnalysis
Gets the analysis for a particular compute resource based on a specific resourceId and analysis type. This tool applies AI-powered analysis to your data to identify anomalies, detect trends, find correlations, and generate actionable recommendations. It can analyze time series data to find significant deviations from normal behavior, compare current performance against historical baselines, and suggest potential root causes based on observed patterns. The analysis includes confidence scores and supporting evidence for each insight, helping you prioritize investigation paths. Use this when you have data but need help interpreting it, when looking for automated anomaly detection, or when you want AI-assisted guidance on troubleshooting.

# Knowledge Base

## AnalyzeDeploymentFailures
Analyzes Azure deployment failures and provides detailed error information for troubleshooting. This tool is useful when you need to: 1) Investigate deployment failures and their root causes, 2) Get detailed error information for failed Azure resource deployments, 3) Understand deployment issues for troubleshooting purposes, or 4) Analyze patterns in deployment failures over time. The output provides comprehensive analysis of deployment failures with actionable insights, including error messages, error codes, correlation IDs for support cases, timestamps, and potential root causes. Use this when deployments fail unexpectedly, when you need to understand the sequence of events in a failed deployment, or when gathering information for escalation to Azure support.

## GetActivityLogsSummary
Retrieves and analyzes Azure Activity Logs for a resource and its connected components. This tool is valuable when you need to: 1) Review recent changes made to a resource and its dependencies, 2) Investigate who made specific configuration changes, 3) Understand patterns of administrative activity, or 4) Detect potentially unauthorized or unusual operations. The output is a natural language summary highlighting key activities, patterns, and potential concerns. Activity Logs record all control plane operations performed on Azure resources, including who performed each action, when it was performed, what operation was attempted, and whether it succeeded or failed. Use this for audit purposes, change tracking, security investigation, and understanding the history of operations.

## GetChangeHistory
Retrieves detailed change history for a specific activity log entry using its correlation ID. This tool is useful when you need to: 1) Get comprehensive details about what changes were made during a specific operation, 2) Understand the complete timeline and context of related operations, 3) Analyze the impact and scope of changes across multiple resources, 4) Investigate deployment parameters, configuration changes, or resource modifications, or 5) Get before/after details when available from Azure deployment history. The output provides detailed analysis including change summary, operation timeline, who made changes, and impact analysis. Use this when users want to drill down into specific activity log entries for more details about what exactly changed and when.

## SearchIncidentKnowledge
Searches a specialized knowledge base (from Agent's past learnings) of past incidents, their investigations, root causes, and resolutions to find relevant historical cases. This knowledge base captures the collective experience of incident resolution, including symptoms, diagnostic steps taken, root causes identified, and remediation actions that worked. The search uses semantic understanding to find similar incidents even when described differently. Results include incident summaries, resolution steps, lessons learned, and links to detailed documentation. Use this when encountering unfamiliar issues, when looking for proven remediation steps, when wanting to learn from past incidents with similar symptoms, and when building on institutional incident response knowledge.

## SearchMemory
Searches the agent's knowledge base and long-term memory for relevant information, finding previously stored context, documentation, runbooks, and learned insights. The memory system stores information from previous interactions, uploaded documents, and curated knowledge articles. This semantic search finds relevant information even when the query doesn't exactly match stored content, using AI-powered understanding of meaning and context. Results are ranked by relevance and include source information. Use this to leverage institutional knowledge during investigations, find relevant documentation, recall information from previous incidents, and access stored runbooks and procedures.

## ShowChangeDiffViewer
Displays a visual change diff viewer showing detailed property-level changes between before and after states. Important: Requires the Correlation ID from a particular Activity Log entry as input. This tool is useful when you need to: 1) Visualize exactly what properties were added, removed, or modified in a resource, 2) Show side-by-side comparison of before and after states with syntax highlighting, 3) Present complex configuration changes in an easy-to-understand visual format, 4) Help users quickly identify specific changes that may have caused issues, or 5) Provide interactive exploration of nested property changes. The output displays an interactive diff viewer with color-coded additions (green), deletions (red), and modifications (yellow). Use this when you want a visual representation of changes rather than text-based analysis.

## UploadKnowledgeDocument
Uploads or overwrites a document in the agent's knowledge base. Use this tool to add new documentation, runbooks, troubleshooting guides, or any text-based knowledge that should be available for future searches. The document will be indexed and made available for semantic search through SearchMemory and SearchIncidentKnowledge tools. Supported file formats: .md (Markdown) and .txt (Plain text). Maximum file size: 16MB. If a document with the same filename already exists, it will be overwritten.

# Log Query

## ExecuteClusterKustoQuery
Executes a fully qualified Kusto query on a specific cluster and database, returning the result in JSON format. KQL is a rich query language optimized for exploring and analyzing big data, supporting filtering, aggregation, joins, time series analysis, and machine learning functions. Azure Data Explorer is commonly used for storing application telemetry, infrastructure logs, security events, and IoT data. The tool supports all KQL operators including where, project, summarize, join, mv-expand, render, and more. Use this for complex log analysis, custom telemetry queries, trend analysis over large datasets, and investigating patterns in structured data stored in Azure Data Explorer.

## GetDimensionValues
Lists all possible values for a specific Geneva/MDM metric dimension, helping understand what filter options are available. For example, if a metric has a 'Region' dimension, this tool would return values like 'eastus', 'westeurope', 'southeastasia', etc. Knowing the actual dimension values is essential for constructing accurate queries and understanding the scope of your data. Use this when building queries with specific dimension filters, when investigating which dimensions have data, when exploring the cardinality of dimensions, or when you need to select specific values for focused analysis.

## GetMetricNames
Lists all metric names available within a specific Geneva/MDM namespace, helping discover what specific measurements can be queried. Each namespace contains multiple metrics measuring different aspects of service behavior—for example, request count, latency percentiles, error rates, queue depths, and resource utilization. This tool returns the complete list of metrics in a namespace with their names, descriptions, units of measurement, and supported aggregation types. Use this after identifying a namespace of interest to see what metrics are available, when building monitoring queries, when exploring unfamiliar services, or when looking for specific types of measurements.

## GetMetricTimeSeriesElementsForAzureResource
Gets time-series metric values for a specific metric name of an Azure resource ID. Returns metric records for the specified start time and end time using 'Average' aggregation with the interval value provided. The data includes timestamps and metric values that can be analyzed for trends, anomalies, and correlations. You can use chart plugins to render visual representations where possible. This tool accesses Azure Monitor metrics to provide granular performance and health data including CPU utilization, memory usage, request counts, latency percentiles, error rates, and resource-specific metrics. Use this for deep performance analysis, capacity planning, SLA monitoring, and correlating metric patterns with incident timelines.

## GetMultipleTimeSeries
Retrieves multiple time series metrics in a single efficient request from Geneva/MDM, enabling comparison and correlation of related metrics. This bulk retrieval tool is optimized for scenarios where you need to analyze several metrics together—for example, comparing CPU, memory, and disk across multiple instances, or correlating request rate with latency and error rate. The tool accepts a list of metric specifications and returns all time series data in a unified response. This is more efficient than individual queries and ensures temporal alignment of the data. Use this for building comprehensive dashboards, performing correlation analysis, comparing metrics across multiple instances, or any scenario requiring multiple related metrics.

## GetNamespaces
Lists all available metric namespaces for Geneva/MDM (Metrics and Diagnostics Monitoring). Namespaces organize metrics into logical groups, typically by service or component—for example, a web service might have namespaces for request metrics, dependency metrics, and infrastructure metrics. This tool queries the Geneva metrics system to enumerate all namespaces accessible to you, showing namespace names and descriptions. Understanding available namespaces is the first step in exploring metrics for an unfamiliar service. Use this when beginning metric exploration, onboarding to monitoring a new service, or when you need to discover what metric categories exist.

## GetTimeSeries
Retrieves time series data for a specific Geneva/MDM metric, providing historical values over a specified time range for trend analysis, anomaly detection, and capacity planning. Time series data shows how metric values change over time, which is fundamental to understanding system behavior. You can specify the metric, dimensions for filtering, time range, aggregation interval (1 minute, 5 minutes, 1 hour, etc.), and aggregation type (Average, Sum, Min, Max, Count). The returned data includes timestamps and values that can be analyzed for patterns or visualized in charts. Use this for investigating metric behavior during incidents, understanding historical trends, performing capacity analysis, and correlating metric changes with events.

## GetTimeSeriesAnalysis
Performs comprehensive statistical analysis on Geneva/MDM time series data, including automated trend detection, anomaly identification, pattern recognition, seasonality analysis, and forecasting. This intelligent analysis provides insights that would require significant manual analysis. The tool applies statistical models to identify significant changes, detect unusual patterns, find correlations with other metrics, and generate forecasts. Results include confidence scores, supporting evidence, and visualizations where applicable. Use this when you need automated analysis of metric behavior, when looking for anomalies without knowing exactly what to look for, when investigating gradual degradation, or when you want data-driven insights to guide your investigation.

## ListAvailableMetrics
Lists all available metrics that can be collected for a specific Azure resource type, helping you discover what performance and health indicators are accessible for monitoring and analysis. Azure resources expose different metrics depending on their type—virtual machines have CPU and disk metrics, web apps have request and response metrics, databases have query and connection metrics, and so on. This tool queries the Azure Monitor metric definitions to show you metric names, descriptions, units, aggregation types (Average, Sum, Count, Minimum, Maximum), and available dimensions. Use this tool when starting an investigation to understand what metrics are available, when building monitoring dashboards, or when you need to find the correct metric name for querying.

## QueryAppInsightsByAppId
Executes a Kusto Query Language (KQL) query against an Application Insights resource using its Application ID (App ID / Instrumentation Key). Application Insights provides comprehensive application monitoring including request tracking, dependency monitoring, exception logging, custom event tracking, and performance metrics. This tool allows you to query all this telemetry data using KQL, which supports complex filtering, aggregation, time-series analysis, and data visualization. Querying by App ID is useful when you have the instrumentation key from application configuration. Use this for deep application diagnostics, tracing individual requests, analyzing error patterns, and investigating performance bottlenecks.

## QueryAppInsightsByResourceId
Executes a Kusto Query Language (KQL) query against an Application Insights resource identified by its Azure resource ID. Application Insights collects rich telemetry including requests, dependencies, exceptions, traces, page views, custom events, and performance metrics. This tool enables powerful analysis using KQL's full capabilities—filtering, aggregation, joins, time analysis, and visualization. Querying by resource ID is useful when you know the Azure resource but not the instrumentation key. Use this for application-level troubleshooting, performance analysis, error investigation, and understanding user experience issues.

## QueryLogAnalyticsByResourceId
Executes a Kusto Query Language (KQL) query against an Azure Log Analytics workspace identified by its Azure resource ID. Log Analytics is Azure's central repository for log data from multiple sources including Azure resources, on-premises servers, applications, security tools, and custom data sources. The workspace aggregates this diverse data, enabling unified analysis across your entire environment. This tool allows querying logs using KQL's powerful capabilities for filtering, correlation, pattern matching, and visualization. Use this for centralized log analysis, security investigation, infrastructure troubleshooting, and cross-resource correlation.

## QueryLogAnalyticsByWorkspaceId
Executes a Kusto Query Language (KQL) query against an Azure Log Analytics workspace using its Workspace ID. Log Analytics workspaces collect and centralize log data from Azure resources, virtual machines, containers, applications, and custom sources. This tool provides access to that centralized data using KQL, which supports sophisticated analysis including time-range filtering, multi-table joins, statistical aggregations, anomaly detection, and result rendering. Querying by Workspace ID is common when you have the ID from workspace properties or configuration. Use this for cross-resource log correlation, security event analysis, infrastructure monitoring, and compliance auditing.

## ValidateQuery
Validates a Kusto query against the specified cluster and database. Returns the number of rows returned by the query or an error message if the query is invalid. The validation checks for syntax errors (typos, malformed expressions), unknown column or table references, type mismatches, deprecated operators, and other issues that would cause the query to fail. The tool returns detailed error messages with line numbers and suggestions for corrections when problems are found. Use this before running complex or unfamiliar queries, when building queries iteratively, when learning KQL syntax, or when you want to verify query correctness before execution.

# Monitoring

## GetDimensionNames
Retrieves the dimension names available for a specific Geneva/MDM metric, showing what attributes can be used to filter and segment metric data. Dimensions are metadata properties attached to each metric value that allow slicing data by attributes like region, instance, status code, customer, endpoint, or environment. Understanding available dimensions is crucial for detailed analysis—for example, seeing latency broken down by region, or error counts filtered to a specific endpoint. Use this when you need to analyze metrics at a granular level, when investigating issues in specific dimensions, or when building detailed monitoring queries.

# Utility

## ExecutePythonCode
Executes Python code in a Jupyter-style environment with full outbound internet connectivity, enabling advanced data processing, web content retrieval, automation, and file generation. The environment comes pre-installed with over 700 commonly used packages including pandas, numpy, matplotlib, seaborn, scikit-learn, requests, beautifulsoup4, and many more. Playwright with Chromium is pre-installed for web scraping, browser automation, and rendering web pages. This tool supports generating downloadable artifacts including PDFs, CSV files, Excel spreadsheets, images, PowerPoint presentations, Word documents, and other file formats—files saved to /mnt/data/ are automatically retrieved and returned as downloadable links. Use this for: retrieving and analyzing web page content, creating complex visualizations (heatmaps, scatter plots, 3D graphics), processing and transforming data, performing statistical analysis and machine learning experiments, calling external HTTP APIs, generating reports and documents, and implementing custom logic not covered by other tools. The environment provides full network access for fetching external data, making API calls, and downloading resources from the internet.

## GetCurrentUtcTime
Gives Agent the current time in UTC. UTC is the standard time reference for distributed systems, logs, and coordination across time zones. This tool is useful for correlating events across systems that use UTC timestamps, calculating time ranges for log queries, ensuring consistent time references during investigation, understanding when events occurred relative to 'now', and providing timestamps for documentation. The returned timestamp includes date, time, and timezone information in a standard format.

# Visualization

## PlotAreaChartWithCorrelation
Generates an interactive area chart that overlays total requests and 5xx errors and marks deployments/rollbacks. If data spans multiple days, the chart consistently starts at midnight of the first day and ends at the current time. You provide chart title, X-axis label (timestamp in ISO-8601 UTC format), Y1-axis label (requests), Y2-axis label (errors), and data points as semicolon-separated rows in the format 'x|y1|y2|correlation|isHighlight|highlightLabel|additionalInfo'. The correlation value is numeric (use 0 if no coefficient), isHighlight draws a marker when true, highlightLabel provides text on markers, and additionalInfo appears in tooltips. Use this for root cause analysis, visualizing the relationship between traffic and errors, and understanding how deployments correlate with incidents.

## PlotBarChart
Generates a bar chart from the provided data and returns it. You provide: chartTitle (displayed at top), xAxisLabel (label for X-axis), yAxisLabel (label for Y-axis), dataPoints (semicolon-separated items in format 'category|value', e.g., 'Q1|120;Q2|80;Q3|60;Q4|90'), and description (a short message to summarize the image). Bar charts excel at showing relative comparisons and making differences between values immediately apparent. Use this to compare performance across multiple resources, show distributions (e.g., error counts by type), display rankings, or compare time periods. Ideal for executive summaries, comparing resource utilization, and identifying outliers in your data.

## PlotHeatmap
Generates a heatmap chart from the provided data and returns it. You provide: chartTitle (displayed at top), xAxisLabel (e.g., 'Time (hours)'), yAxisLabel (e.g., 'Temperature (°C)'), dataPoints (semicolon-separated items in format 'x|y|value', e.g., '12:00|25|8.5;12:00|30|4.2;13:00|25|9.1' where x is the x-axis position, y is the y-axis position, and value is the intensity), and description (a short summary). Heatmaps use color gradients to show intensity across two dimensions, making them excellent for spotting patterns, anomalies, and high-activity periods. Use this for visualizing time-based patterns (like request volume by hour and day), showing correlations between dimensions, and identifying hotspots in your data.

## PlotPieChart
Generates a pie chart visualization to show the proportional distribution of values as segments of a whole, making it easy to understand relative contributions and percentages at a glance. Pie charts are ideal for showing how different components contribute to a total—for example, error distribution by error type, traffic distribution by region, resource consumption by application, or request distribution by endpoint. Each segment is sized proportionally and labeled with both the category name and its percentage. The tool automatically handles legends, color assignment, and segment labeling for clear presentation. Use this for executive-friendly visualizations, understanding composition of totals, and communicating proportional breakdowns in incident summaries or reports.

## PlotScatter
Generates a scatter plot from X-Y coordinate pairs and returns it. You provide: chartTitle (displayed at top), xAxisLabel (label for X-axis), yAxisLabel (label for Y-axis), dataPoints (semicolon-separated items in format 'x|y|label', e.g., '1.2|3.4|Point A;2.3|4.5|Point B;3.4|5.6|Point C'), and description (a short summary). Scatter plots are essential for identifying correlations (positive, negative, or none), detecting clusters of similar behavior, finding outliers that deviate from patterns, and understanding the spread of your data. Use this for statistical analysis, hypothesis testing, and exploring relationships between metrics during root cause analysis.